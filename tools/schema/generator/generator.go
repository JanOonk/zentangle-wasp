// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

package generator

import (
	"bufio"
	"fmt"
	"os"
	"regexp"
	"strings"
)

// TODO nested structs
// TODO handle case where owner is type AgentID[]

const (
	AccessChain         = "chain"
	AccessCreator       = "creator"
	AccessSelf          = "self"
	AliasThis           = "this"
	InitFunc            = "Init"
	KindFunc            = "Func"
	KindView            = "View"
	PropImmutable       = "Immutable"
	PropMutable         = "Mutable"
	SpecialFuncInit     = "funcInit"
	SpecialFuncSetOwner = "setOwner"
	SpecialViewGetOwner = "getOwner"
)

var (
	ModuleCwd  = "???"
	ModuleName = "???"
	ModulePath = "???"
)

type Generator interface {
	funcName(f *Func) string
	generateFuncSignature(f *Func)
	generateLanguageSpecificFiles() error
	generateProxyArray(field *Field, mutability, arrayType, proxyType string)
	generateProxyMap(field *Field, mutability, mapType, proxyType string)
	generateProxyReference(field *Field, mutability, typeName string)
	writeConsts()
	writeContract()
	writeInitialFuncs()
	writeKeys()
	writeLib()
	writeParams()
	writeResults()
	writeState()
	writeStructs()
	writeTypeDefs()
}

type GenBase struct {
	extension      string
	file           *os.File
	Folder         string
	funcRegexp     *regexp.Regexp
	gen            Generator
	language       string
	NewTypes       map[string]bool
	rootFolder     string
	s              *Schema
	skipDisclaimer bool
}

func (g *GenBase) close() {
	_ = g.file.Close()
}

// TODO take copyright from schema?
func (g *GenBase) copyright() string {
	text := "// Copyright 2020 IOTA Stiftung\n" +
		"// SPDX-License-Identifier: Apache-2.0\n"
	if !g.skipDisclaimer {
		text += "\n// (Re-)generated by schema tool\n" +
			"// >>>> DO NOT CHANGE THIS FILE! <<<<\n" +
			"// Change the json schema instead\n"
	}
	return text
}

func (g *GenBase) create(path string) (err error) {
	g.file, err = os.Create(path)
	return err
}

func (g *GenBase) createSourceFile(name string, generator func()) error {
	err := g.create(g.Folder + name + g.extension)
	if err != nil {
		return err
	}
	defer g.close()

	// always add copyright to source file
	g.println(g.copyright())
	g.skipDisclaimer = false
	generator()
	return nil
}

func (g *GenBase) exists(path string) (err error) {
	_, err = os.Stat(path)
	return err
}

func (g *GenBase) formatter(on bool) {
	if on {
		g.printf("\n// @formatter:%s\n", "on")
		return
	}
	g.printf("// @formatter:%s\n\n", "off")
}

func (g *GenBase) Generate(s *Schema) error {
	g.s = s
	g.NewTypes = make(map[string]bool)

	g.Folder = g.rootFolder + "/"
	if g.rootFolder != "src" {
		module := strings.ReplaceAll(ModuleCwd, "\\", "/")
		module = module[strings.LastIndex(module, "/")+1:]
		g.Folder += module + "/"
	}
	if g.s.CoreContracts {
		g.Folder += g.s.Name + "/"
	}

	err := os.MkdirAll(g.Folder, 0o755)
	if err != nil {
		return err
	}
	info, err := os.Stat(g.Folder + "consts" + g.extension)
	if err == nil && info.ModTime().After(s.SchemaTime) {
		fmt.Printf("skipping %s code generation\n", g.language)
		return nil
	}

	fmt.Printf("generating %s code\n", g.language)
	err = g.generateCode()
	if err != nil {
		return err
	}
	if !g.s.CoreContracts {
		err = g.generateTests()
		if err != nil {
			return err
		}
	}
	return nil
}

func (g *GenBase) generateCode() error {
	err := g.createSourceFile("consts", g.gen.writeConsts)
	if err != nil {
		return err
	}
	if len(g.s.Structs) != 0 {
		err = g.createSourceFile("structs", g.gen.writeStructs)
		if err != nil {
			return err
		}
	}
	if len(g.s.Typedefs) != 0 {
		err = g.createSourceFile("typedefs", g.gen.writeTypeDefs)
		if err != nil {
			return err
		}
	}
	if len(g.s.Params) != 0 {
		err = g.createSourceFile("params", g.gen.writeParams)
		if err != nil {
			return err
		}
	}
	if len(g.s.Results) != 0 {
		err = g.createSourceFile("results", g.gen.writeResults)
		if err != nil {
			return err
		}
	}
	err = g.createSourceFile("contract", g.gen.writeContract)
	if err != nil {
		return err
	}

	if !g.s.CoreContracts {
		err = g.createSourceFile("keys", g.gen.writeKeys)
		if err != nil {
			return err
		}
		err = g.createSourceFile("state", g.gen.writeState)
		if err != nil {
			return err
		}
		err = g.createSourceFile("lib", g.gen.writeLib)
		if err != nil {
			return err
		}
		err = g.generateFuncs()
		if err != nil {
			return err
		}
	}

	return g.gen.generateLanguageSpecificFiles()
}

func (g *GenBase) generateFuncs() error {
	scFileName := g.Folder + g.s.Name + g.extension
	err := g.open(g.Folder + g.s.Name + g.extension)
	if err != nil {
		// generate initial SC function file
		g.skipDisclaimer = true
		return g.createSourceFile(g.s.Name, g.gen.writeInitialFuncs)
	}

	// append missing function signatures to existing code file

	// scan existing file for signatures
	lines, existing, err := g.scanExistingCode()
	if err != nil {
		return err
	}

	// save old one from overwrite
	scOriginal := g.Folder + g.s.Name + ".bak"
	err = os.Rename(scFileName, scOriginal)
	if err != nil {
		return err
	}
	err = g.create(scFileName)
	if err != nil {
		return err
	}
	defer g.close()

	// make copy of file
	for _, line := range lines {
		g.println(line)
	}

	// append any new funcs
	for _, f := range g.s.Funcs {
		if existing[g.gen.funcName(f)] == "" {
			g.gen.generateFuncSignature(f)
		}
	}

	return os.Remove(scOriginal)
}

func (g *GenBase) generateProxy(field *Field, mutability string) {
	if field.Array {
		proxyType := mutability + field.Type
		arrayType := "ArrayOf" + proxyType
		if !g.NewTypes[arrayType] {
			g.NewTypes[arrayType] = true
			g.gen.generateProxyArray(field, mutability, arrayType, proxyType)
		}
		g.gen.generateProxyReference(field, mutability, arrayType)
		return
	}

	if field.MapKey != "" {
		proxyType := mutability + field.Type
		mapType := "Map" + field.MapKey + "To" + proxyType
		if !g.NewTypes[mapType] {
			g.NewTypes[mapType] = true
			g.gen.generateProxyMap(field, mutability, mapType, proxyType)
		}
		g.gen.generateProxyReference(field, mutability, mapType)
	}
}

func (g *GenBase) generateTests() error {
	err := os.MkdirAll("test", 0o755)
	if err != nil {
		return err
	}

	// do not overwrite existing file
	name := strings.ToLower(g.s.Name)
	filename := "test/" + name + "_test.go"
	err = g.exists(filename)
	if err == nil {
		return nil
	}

	err = g.create(filename)
	if err != nil {
		return err
	}
	defer g.close()

	module := ModuleName + strings.ReplaceAll(ModuleCwd[len(ModulePath):], "\\", "/")
	g.println("package test")
	g.println()
	g.println("import (")
	g.println("\t\"testing\"")
	g.println()
	g.printf("\t\"%s/go/%s\"\n", module, g.s.Name)
	g.println("\t\"github.com/iotaledger/wasp/packages/vm/wasmsolo\"")
	g.println("\t\"github.com/stretchr/testify/require\"")
	g.println(")")
	g.println()
	g.println("func TestDeploy(t *testing.T) {")
	g.printf("\tctx := wasmsolo.NewSoloContext(t, %s.ScName, %s.OnLoad)\n", name, name)
	g.printf("\trequire.NoError(t, ctx.ContractExists(%s.ScName))\n", name)
	g.println("}")

	return nil
}

func (g *GenBase) open(path string) (err error) {
	g.file, err = os.Open(path)
	return err
}

func (g *GenBase) printf(format string, a ...interface{}) {
	_, _ = fmt.Fprintf(g.file, format, a...)
}

func (g *GenBase) println(a ...interface{}) {
	_, _ = fmt.Fprintln(g.file, a...)
}

func (g *GenBase) scanExistingCode() ([]string, StringMap, error) {
	defer g.close()
	existing := make(StringMap)
	lines := make([]string, 0)
	scanner := bufio.NewScanner(g.file)
	for scanner.Scan() {
		line := scanner.Text()
		matches := g.funcRegexp.FindStringSubmatch(line)
		if matches != nil {
			existing[matches[1]] = line
		}
		lines = append(lines, line)
	}
	err := scanner.Err()
	if err != nil {
		return nil, nil, err
	}
	return lines, existing, nil
}
