// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
// >>>> DO NOT CHANGE THIS FILE! <<<<
// Change the json schema instead

import * as wasmlib from "wasmlib";
import * as sc from "./index";

export class ArrayOfImmutableBet {
	objID: i32;

    constructor(objID: i32) {
        this.objID = objID;
    }

    length(): i32 {
        return wasmlib.getLength(this.objID);
    }

	getBet(index: i32): sc.ImmutableBet {
		return new sc.ImmutableBet(this.objID, new wasmlib.Key32(index));
	}
}

export class MapStringToImmutableBet {
	objID: i32;

    constructor(objID: i32) {
        this.objID = objID;
    }

    getBet(key: string): sc.ImmutableBet {
        return new sc.ImmutableBet(this.objID, wasmlib.Key32.fromString(key));
    }
}

export class MapStringToImmutablePlayer {
	objID: i32;

    constructor(objID: i32) {
        this.objID = objID;
    }

    getPlayer(key: string): sc.ImmutablePlayer {
        return new sc.ImmutablePlayer(this.objID, wasmlib.Key32.fromString(key));
    }
}

export class ArrayOfImmutableInt32 {
	objID: i32;

    constructor(objID: i32) {
        this.objID = objID;
    }

    length(): i32 {
        return wasmlib.getLength(this.objID);
    }

    getInt32(index: i32): wasmlib.ScImmutableInt32 {
        return new wasmlib.ScImmutableInt32(this.objID, new wasmlib.Key32(index));
    }
}

export class ArrayOfImmutableTaggedImage {
	objID: i32;

    constructor(objID: i32) {
        this.objID = objID;
    }

    length(): i32 {
        return wasmlib.getLength(this.objID);
    }

	getTaggedImage(index: i32): sc.ImmutableTaggedImage {
		return new sc.ImmutableTaggedImage(this.objID, new wasmlib.Key32(index));
	}
}

export class ArrayOfImmutableValidTag {
	objID: i32;

    constructor(objID: i32) {
        this.objID = objID;
    }

    length(): i32 {
        return wasmlib.getLength(this.objID);
    }

	getValidTag(index: i32): sc.ImmutableValidTag {
		return new sc.ImmutableValidTag(this.objID, new wasmlib.Key32(index));
	}
}

export class ImmutablezentangleState extends wasmlib.ScMapID {
    bets(): sc.ArrayOfImmutableBet {
		let arrID = wasmlib.getObjectID(this.mapID, sc.idxMap[sc.IdxStateBets], wasmlib.TYPE_ARRAY|wasmlib.TYPE_BYTES);
		return new sc.ArrayOfImmutableBet(arrID);
	}

    creator(): wasmlib.ScImmutableAgentID {
		return new wasmlib.ScImmutableAgentID(this.mapID, sc.idxMap[sc.IdxStateCreator]);
	}

    description(): wasmlib.ScImmutableString {
		return new wasmlib.ScImmutableString(this.mapID, sc.idxMap[sc.IdxStateDescription]);
	}

    numberOfImages(): wasmlib.ScImmutableInt32 {
		return new wasmlib.ScImmutableInt32(this.mapID, sc.idxMap[sc.IdxStateNumberOfImages]);
	}

    owner(): wasmlib.ScImmutableAgentID {
		return new wasmlib.ScImmutableAgentID(this.mapID, sc.idxMap[sc.IdxStateOwner]);
	}

    pendingPlay(): sc.MapStringToImmutableBet {
		let mapID = wasmlib.getObjectID(this.mapID, sc.idxMap[sc.IdxStatePendingPlay], wasmlib.TYPE_MAP);
		return new sc.MapStringToImmutableBet(mapID);
	}

    player(): sc.MapStringToImmutablePlayer {
		let mapID = wasmlib.getObjectID(this.mapID, sc.idxMap[sc.IdxStatePlayer], wasmlib.TYPE_MAP);
		return new sc.MapStringToImmutablePlayer(mapID);
	}

    playsPerImage(): sc.ArrayOfImmutableInt32 {
		let arrID = wasmlib.getObjectID(this.mapID, sc.idxMap[sc.IdxStatePlaysPerImage], wasmlib.TYPE_ARRAY|wasmlib.TYPE_INT32);
		return new sc.ArrayOfImmutableInt32(arrID);
	}

    processedImages(): sc.ArrayOfImmutableTaggedImage {
		let arrID = wasmlib.getObjectID(this.mapID, sc.idxMap[sc.IdxStateProcessedImages], wasmlib.TYPE_ARRAY|wasmlib.TYPE_BYTES);
		return new sc.ArrayOfImmutableTaggedImage(arrID);
	}

    reward(): wasmlib.ScImmutableInt64 {
		return new wasmlib.ScImmutableInt64(this.mapID, sc.idxMap[sc.IdxStateReward]);
	}

    taggedImages(): sc.ArrayOfImmutableTaggedImage {
		let arrID = wasmlib.getObjectID(this.mapID, sc.idxMap[sc.IdxStateTaggedImages], wasmlib.TYPE_ARRAY|wasmlib.TYPE_BYTES);
		return new sc.ArrayOfImmutableTaggedImage(arrID);
	}

    tagsRequiredPerImage(): wasmlib.ScImmutableInt32 {
		return new wasmlib.ScImmutableInt32(this.mapID, sc.idxMap[sc.IdxStateTagsRequiredPerImage]);
	}

    validTags(): sc.ArrayOfImmutableValidTag {
		let arrID = wasmlib.getObjectID(this.mapID, sc.idxMap[sc.IdxStateValidTags], wasmlib.TYPE_ARRAY|wasmlib.TYPE_BYTES);
		return new sc.ArrayOfImmutableValidTag(arrID);
	}
}

export class ArrayOfMutableBet {
	objID: i32;

    constructor(objID: i32) {
        this.objID = objID;
    }

    clear(): void {
        wasmlib.clear(this.objID);
    }

    length(): i32 {
        return wasmlib.getLength(this.objID);
    }

	getBet(index: i32): sc.MutableBet {
		return new sc.MutableBet(this.objID, new wasmlib.Key32(index));
	}
}

export class MapStringToMutableBet {
	objID: i32;

    constructor(objID: i32) {
        this.objID = objID;
    }

    clear(): void {
        wasmlib.clear(this.objID);
    }

    getBet(key: string): sc.MutableBet {
        return new sc.MutableBet(this.objID, wasmlib.Key32.fromString(key));
    }
}

export class MapStringToMutablePlayer {
	objID: i32;

    constructor(objID: i32) {
        this.objID = objID;
    }

    clear(): void {
        wasmlib.clear(this.objID);
    }

    getPlayer(key: string): sc.MutablePlayer {
        return new sc.MutablePlayer(this.objID, wasmlib.Key32.fromString(key));
    }
}

export class ArrayOfMutableInt32 {
	objID: i32;

    constructor(objID: i32) {
        this.objID = objID;
    }

    clear(): void {
        wasmlib.clear(this.objID);
    }

    length(): i32 {
        return wasmlib.getLength(this.objID);
    }

    getInt32(index: i32): wasmlib.ScMutableInt32 {
        return new wasmlib.ScMutableInt32(this.objID, new wasmlib.Key32(index));
    }
}

export class ArrayOfMutableTaggedImage {
	objID: i32;

    constructor(objID: i32) {
        this.objID = objID;
    }

    clear(): void {
        wasmlib.clear(this.objID);
    }

    length(): i32 {
        return wasmlib.getLength(this.objID);
    }

	getTaggedImage(index: i32): sc.MutableTaggedImage {
		return new sc.MutableTaggedImage(this.objID, new wasmlib.Key32(index));
	}
}

export class ArrayOfMutableValidTag {
	objID: i32;

    constructor(objID: i32) {
        this.objID = objID;
    }

    clear(): void {
        wasmlib.clear(this.objID);
    }

    length(): i32 {
        return wasmlib.getLength(this.objID);
    }

	getValidTag(index: i32): sc.MutableValidTag {
		return new sc.MutableValidTag(this.objID, new wasmlib.Key32(index));
	}
}

export class MutablezentangleState extends wasmlib.ScMapID {
    asImmutable(): sc.ImmutablezentangleState {
		const imm = new sc.ImmutablezentangleState();
		imm.mapID = this.mapID;
		return imm;
	}

    bets(): sc.ArrayOfMutableBet {
		let arrID = wasmlib.getObjectID(this.mapID, sc.idxMap[sc.IdxStateBets], wasmlib.TYPE_ARRAY|wasmlib.TYPE_BYTES);
		return new sc.ArrayOfMutableBet(arrID);
	}

    creator(): wasmlib.ScMutableAgentID {
		return new wasmlib.ScMutableAgentID(this.mapID, sc.idxMap[sc.IdxStateCreator]);
	}

    description(): wasmlib.ScMutableString {
		return new wasmlib.ScMutableString(this.mapID, sc.idxMap[sc.IdxStateDescription]);
	}

    numberOfImages(): wasmlib.ScMutableInt32 {
		return new wasmlib.ScMutableInt32(this.mapID, sc.idxMap[sc.IdxStateNumberOfImages]);
	}

    owner(): wasmlib.ScMutableAgentID {
		return new wasmlib.ScMutableAgentID(this.mapID, sc.idxMap[sc.IdxStateOwner]);
	}

    pendingPlay(): sc.MapStringToMutableBet {
		let mapID = wasmlib.getObjectID(this.mapID, sc.idxMap[sc.IdxStatePendingPlay], wasmlib.TYPE_MAP);
		return new sc.MapStringToMutableBet(mapID);
	}

    player(): sc.MapStringToMutablePlayer {
		let mapID = wasmlib.getObjectID(this.mapID, sc.idxMap[sc.IdxStatePlayer], wasmlib.TYPE_MAP);
		return new sc.MapStringToMutablePlayer(mapID);
	}

    playsPerImage(): sc.ArrayOfMutableInt32 {
		let arrID = wasmlib.getObjectID(this.mapID, sc.idxMap[sc.IdxStatePlaysPerImage], wasmlib.TYPE_ARRAY|wasmlib.TYPE_INT32);
		return new sc.ArrayOfMutableInt32(arrID);
	}

    processedImages(): sc.ArrayOfMutableTaggedImage {
		let arrID = wasmlib.getObjectID(this.mapID, sc.idxMap[sc.IdxStateProcessedImages], wasmlib.TYPE_ARRAY|wasmlib.TYPE_BYTES);
		return new sc.ArrayOfMutableTaggedImage(arrID);
	}

    reward(): wasmlib.ScMutableInt64 {
		return new wasmlib.ScMutableInt64(this.mapID, sc.idxMap[sc.IdxStateReward]);
	}

    taggedImages(): sc.ArrayOfMutableTaggedImage {
		let arrID = wasmlib.getObjectID(this.mapID, sc.idxMap[sc.IdxStateTaggedImages], wasmlib.TYPE_ARRAY|wasmlib.TYPE_BYTES);
		return new sc.ArrayOfMutableTaggedImage(arrID);
	}

    tagsRequiredPerImage(): wasmlib.ScMutableInt32 {
		return new wasmlib.ScMutableInt32(this.mapID, sc.idxMap[sc.IdxStateTagsRequiredPerImage]);
	}

    validTags(): sc.ArrayOfMutableValidTag {
		let arrID = wasmlib.getObjectID(this.mapID, sc.idxMap[sc.IdxStateValidTags], wasmlib.TYPE_ARRAY|wasmlib.TYPE_BYTES);
		return new sc.ArrayOfMutableValidTag(arrID);
	}
}
