// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
// >>>> DO NOT CHANGE THIS FILE! <<<<
// Change the json schema instead

#![allow(dead_code)]
#![allow(unused_imports)]

use erc721::*;
use wasmlib::*;
use wasmlib::host::*;

use crate::consts::*;
use crate::events::*;
use crate::keys::*;
use crate::params::*;
use crate::results::*;
use crate::state::*;

mod consts;
mod contract;
mod events;
mod keys;
mod params;
mod results;
mod state;
mod typedefs;
mod erc721;

#[no_mangle]
fn on_load() {
    let exports = ScExports::new();
    exports.add_func(FUNC_APPROVE,              func_approve_thunk);
    exports.add_func(FUNC_BURN,                 func_burn_thunk);
    exports.add_func(FUNC_INIT,                 func_init_thunk);
    exports.add_func(FUNC_MINT,                 func_mint_thunk);
    exports.add_func(FUNC_SAFE_TRANSFER_FROM,   func_safe_transfer_from_thunk);
    exports.add_func(FUNC_SET_APPROVAL_FOR_ALL, func_set_approval_for_all_thunk);
    exports.add_func(FUNC_TRANSFER_FROM,        func_transfer_from_thunk);
    exports.add_view(VIEW_BALANCE_OF,           view_balance_of_thunk);
    exports.add_view(VIEW_GET_APPROVED,         view_get_approved_thunk);
    exports.add_view(VIEW_IS_APPROVED_FOR_ALL,  view_is_approved_for_all_thunk);
    exports.add_view(VIEW_NAME,                 view_name_thunk);
    exports.add_view(VIEW_OWNER_OF,             view_owner_of_thunk);
    exports.add_view(VIEW_SYMBOL,               view_symbol_thunk);
    exports.add_view(VIEW_TOKEN_URI,            view_token_uri_thunk);

    unsafe {
        for i in 0..KEY_MAP_LEN {
            IDX_MAP[i] = get_key_id_from_string(KEY_MAP[i]);
        }
    }
}

pub struct ApproveContext {
	events:  Erc721Events,
	params: ImmutableApproveParams,
	state: MutableErc721State,
}

fn func_approve_thunk(ctx: &ScFuncContext) {
	ctx.log("erc721.funcApprove");
	let f = ApproveContext {
		events:  Erc721Events {},
		params: ImmutableApproveParams {
			id: OBJ_ID_PARAMS,
		},
		state: MutableErc721State {
			id: OBJ_ID_STATE,
		},
	};
	ctx.require(f.params.token_id().exists(), "missing mandatory tokenID");
	func_approve(ctx, &f);
	ctx.log("erc721.funcApprove ok");
}

pub struct BurnContext {
	events:  Erc721Events,
	params: ImmutableBurnParams,
	state: MutableErc721State,
}

fn func_burn_thunk(ctx: &ScFuncContext) {
	ctx.log("erc721.funcBurn");
	let f = BurnContext {
		events:  Erc721Events {},
		params: ImmutableBurnParams {
			id: OBJ_ID_PARAMS,
		},
		state: MutableErc721State {
			id: OBJ_ID_STATE,
		},
	};
	ctx.require(f.params.token_id().exists(), "missing mandatory tokenID");
	func_burn(ctx, &f);
	ctx.log("erc721.funcBurn ok");
}

pub struct InitContext {
	events:  Erc721Events,
	params: ImmutableInitParams,
	state: MutableErc721State,
}

fn func_init_thunk(ctx: &ScFuncContext) {
	ctx.log("erc721.funcInit");
	let f = InitContext {
		events:  Erc721Events {},
		params: ImmutableInitParams {
			id: OBJ_ID_PARAMS,
		},
		state: MutableErc721State {
			id: OBJ_ID_STATE,
		},
	};
	ctx.require(f.params.name().exists(), "missing mandatory name");
	ctx.require(f.params.symbol().exists(), "missing mandatory symbol");
	func_init(ctx, &f);
	ctx.log("erc721.funcInit ok");
}

pub struct MintContext {
	events:  Erc721Events,
	params: ImmutableMintParams,
	state: MutableErc721State,
}

fn func_mint_thunk(ctx: &ScFuncContext) {
	ctx.log("erc721.funcMint");
	let f = MintContext {
		events:  Erc721Events {},
		params: ImmutableMintParams {
			id: OBJ_ID_PARAMS,
		},
		state: MutableErc721State {
			id: OBJ_ID_STATE,
		},
	};
	ctx.require(f.params.token_id().exists(), "missing mandatory tokenID");
	func_mint(ctx, &f);
	ctx.log("erc721.funcMint ok");
}

pub struct SafeTransferFromContext {
	events:  Erc721Events,
	params: ImmutableSafeTransferFromParams,
	state: MutableErc721State,
}

fn func_safe_transfer_from_thunk(ctx: &ScFuncContext) {
	ctx.log("erc721.funcSafeTransferFrom");
	let f = SafeTransferFromContext {
		events:  Erc721Events {},
		params: ImmutableSafeTransferFromParams {
			id: OBJ_ID_PARAMS,
		},
		state: MutableErc721State {
			id: OBJ_ID_STATE,
		},
	};
	ctx.require(f.params.from().exists(), "missing mandatory from");
	ctx.require(f.params.to().exists(), "missing mandatory to");
	ctx.require(f.params.token_id().exists(), "missing mandatory tokenID");
	func_safe_transfer_from(ctx, &f);
	ctx.log("erc721.funcSafeTransferFrom ok");
}

pub struct SetApprovalForAllContext {
	events:  Erc721Events,
	params: ImmutableSetApprovalForAllParams,
	state: MutableErc721State,
}

fn func_set_approval_for_all_thunk(ctx: &ScFuncContext) {
	ctx.log("erc721.funcSetApprovalForAll");
	let f = SetApprovalForAllContext {
		events:  Erc721Events {},
		params: ImmutableSetApprovalForAllParams {
			id: OBJ_ID_PARAMS,
		},
		state: MutableErc721State {
			id: OBJ_ID_STATE,
		},
	};
	ctx.require(f.params.approval().exists(), "missing mandatory approval");
	ctx.require(f.params.operator().exists(), "missing mandatory operator");
	func_set_approval_for_all(ctx, &f);
	ctx.log("erc721.funcSetApprovalForAll ok");
}

pub struct TransferFromContext {
	events:  Erc721Events,
	params: ImmutableTransferFromParams,
	state: MutableErc721State,
}

fn func_transfer_from_thunk(ctx: &ScFuncContext) {
	ctx.log("erc721.funcTransferFrom");
	let f = TransferFromContext {
		events:  Erc721Events {},
		params: ImmutableTransferFromParams {
			id: OBJ_ID_PARAMS,
		},
		state: MutableErc721State {
			id: OBJ_ID_STATE,
		},
	};
	ctx.require(f.params.from().exists(), "missing mandatory from");
	ctx.require(f.params.to().exists(), "missing mandatory to");
	ctx.require(f.params.token_id().exists(), "missing mandatory tokenID");
	func_transfer_from(ctx, &f);
	ctx.log("erc721.funcTransferFrom ok");
}

pub struct BalanceOfContext {
	params: ImmutableBalanceOfParams,
	results: MutableBalanceOfResults,
	state: ImmutableErc721State,
}

fn view_balance_of_thunk(ctx: &ScViewContext) {
	ctx.log("erc721.viewBalanceOf");
	let f = BalanceOfContext {
		params: ImmutableBalanceOfParams {
			id: OBJ_ID_PARAMS,
		},
		results: MutableBalanceOfResults {
			id: OBJ_ID_RESULTS,
		},
		state: ImmutableErc721State {
			id: OBJ_ID_STATE,
		},
	};
	ctx.require(f.params.owner().exists(), "missing mandatory owner");
	view_balance_of(ctx, &f);
	ctx.log("erc721.viewBalanceOf ok");
}

pub struct GetApprovedContext {
	params: ImmutableGetApprovedParams,
	results: MutableGetApprovedResults,
	state: ImmutableErc721State,
}

fn view_get_approved_thunk(ctx: &ScViewContext) {
	ctx.log("erc721.viewGetApproved");
	let f = GetApprovedContext {
		params: ImmutableGetApprovedParams {
			id: OBJ_ID_PARAMS,
		},
		results: MutableGetApprovedResults {
			id: OBJ_ID_RESULTS,
		},
		state: ImmutableErc721State {
			id: OBJ_ID_STATE,
		},
	};
	ctx.require(f.params.token_id().exists(), "missing mandatory tokenID");
	view_get_approved(ctx, &f);
	ctx.log("erc721.viewGetApproved ok");
}

pub struct IsApprovedForAllContext {
	params: ImmutableIsApprovedForAllParams,
	results: MutableIsApprovedForAllResults,
	state: ImmutableErc721State,
}

fn view_is_approved_for_all_thunk(ctx: &ScViewContext) {
	ctx.log("erc721.viewIsApprovedForAll");
	let f = IsApprovedForAllContext {
		params: ImmutableIsApprovedForAllParams {
			id: OBJ_ID_PARAMS,
		},
		results: MutableIsApprovedForAllResults {
			id: OBJ_ID_RESULTS,
		},
		state: ImmutableErc721State {
			id: OBJ_ID_STATE,
		},
	};
	ctx.require(f.params.operator().exists(), "missing mandatory operator");
	ctx.require(f.params.owner().exists(), "missing mandatory owner");
	view_is_approved_for_all(ctx, &f);
	ctx.log("erc721.viewIsApprovedForAll ok");
}

pub struct NameContext {
	results: MutableNameResults,
	state: ImmutableErc721State,
}

fn view_name_thunk(ctx: &ScViewContext) {
	ctx.log("erc721.viewName");
	let f = NameContext {
		results: MutableNameResults {
			id: OBJ_ID_RESULTS,
		},
		state: ImmutableErc721State {
			id: OBJ_ID_STATE,
		},
	};
	view_name(ctx, &f);
	ctx.log("erc721.viewName ok");
}

pub struct OwnerOfContext {
	params: ImmutableOwnerOfParams,
	results: MutableOwnerOfResults,
	state: ImmutableErc721State,
}

fn view_owner_of_thunk(ctx: &ScViewContext) {
	ctx.log("erc721.viewOwnerOf");
	let f = OwnerOfContext {
		params: ImmutableOwnerOfParams {
			id: OBJ_ID_PARAMS,
		},
		results: MutableOwnerOfResults {
			id: OBJ_ID_RESULTS,
		},
		state: ImmutableErc721State {
			id: OBJ_ID_STATE,
		},
	};
	ctx.require(f.params.token_id().exists(), "missing mandatory tokenID");
	view_owner_of(ctx, &f);
	ctx.log("erc721.viewOwnerOf ok");
}

pub struct SymbolContext {
	results: MutableSymbolResults,
	state: ImmutableErc721State,
}

fn view_symbol_thunk(ctx: &ScViewContext) {
	ctx.log("erc721.viewSymbol");
	let f = SymbolContext {
		results: MutableSymbolResults {
			id: OBJ_ID_RESULTS,
		},
		state: ImmutableErc721State {
			id: OBJ_ID_STATE,
		},
	};
	view_symbol(ctx, &f);
	ctx.log("erc721.viewSymbol ok");
}

pub struct TokenURIContext {
	params: ImmutableTokenURIParams,
	results: MutableTokenURIResults,
	state: ImmutableErc721State,
}

fn view_token_uri_thunk(ctx: &ScViewContext) {
	ctx.log("erc721.viewTokenURI");
	let f = TokenURIContext {
		params: ImmutableTokenURIParams {
			id: OBJ_ID_PARAMS,
		},
		results: MutableTokenURIResults {
			id: OBJ_ID_RESULTS,
		},
		state: ImmutableErc721State {
			id: OBJ_ID_STATE,
		},
	};
	ctx.require(f.params.token_id().exists(), "missing mandatory tokenID");
	view_token_uri(ctx, &f);
	ctx.log("erc721.viewTokenURI ok");
}
